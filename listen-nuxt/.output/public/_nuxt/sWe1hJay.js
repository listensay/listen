import{L as w,r as d,M as C,N as b,O as B,P as v,G as O,m as R,Q as E,R as M,K as H,S as I,T,q,v as z,U as K,t as N}from"./FvKkF2AP.js";const S=s=>s==="defer"||s===!1;function $(...s){var D;const n=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(n);let[e,l,a={}]=s;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof l!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=R(),f=l,_=()=>null,p=()=>t.isHydrating?t.payload.data[e]:t.static.data[e];a.server=a.server??!0,a.default=a.default??_,a.getCachedData=a.getCachedData??p,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??w.deep,a.dedupe=a.dedupe??"cancel";const y=()=>a.getCachedData(e,t)!=null;if(!t._asyncData[e]||!a.immediate){(D=t.payload._errors)[e]??(D[e]=null);const o=a.deep?d:C;t._asyncData[e]={data:o(a.getCachedData(e,t)??a.default()),pending:d(!y()),error:b(t.payload._errors,e),status:d("idle")}}const r={...t._asyncData[e]};r.refresh=r.execute=(o={})=>{if(t._asyncDataPromises[e]){if(S(o.dedupe??a.dedupe))return t._asyncDataPromises[e];t._asyncDataPromises[e].cancelled=!0}if((o._initial||t.isHydrating&&o._initial!==!1)&&y())return Promise.resolve(a.getCachedData(e,t));r.pending.value=!0,r.status.value="pending";const u=new Promise((i,c)=>{try{i(f(t))}catch(P){c(P)}}).then(async i=>{if(u.cancelled)return t._asyncDataPromises[e];let c=i;a.transform&&(c=await a.transform(i)),a.pick&&(c=U(c,a.pick)),t.payload.data[e]=c,r.data.value=c,r.error.value=null,r.status.value="success"}).catch(i=>{if(u.cancelled)return t._asyncDataPromises[e];r.error.value=E(i),r.data.value=M(a.default()),r.status.value="error"}).finally(()=>{u.cancelled||(r.pending.value=!1,delete t._asyncDataPromises[e])});return t._asyncDataPromises[e]=u,t._asyncDataPromises[e]},r.clear=()=>j(t,e);const h=()=>r.refresh({_initial:!0}),g=a.server!==!1&&t.payload.serverRendered;{const o=H();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const i=o._nuxtOnBeforeMountCbs;o&&(B(()=>{i.forEach(c=>{c()}),i.splice(0,i.length)}),v(()=>i.splice(0,i.length)))}g&&t.isHydrating&&(r.error.value||y())?(r.pending.value=!1,r.status.value=r.error.value?"error":"success"):o&&(t.payload.serverRendered&&t.isHydrating||a.lazy)&&a.immediate?o._nuxtOnBeforeMountCbs.push(h):a.immediate&&h(),a.watch&&O(a.watch,()=>r.refresh());const u=t.hook("app:data:refresh",async i=>{(!i||i.includes(e))&&await r.refresh()});o&&v(u)}const m=Promise.resolve(t._asyncDataPromises[e]).then(()=>r);return Object.assign(m,r),m}function j(s,n){n in s.payload.data&&(s.payload.data[n]=void 0),n in s.payload._errors&&(s.payload._errors[n]=null),s._asyncData[n]&&(s._asyncData[n].data.value=void 0,s._asyncData[n].error.value=null,s._asyncData[n].pending.value=!1,s._asyncData[n].status.value="idle"),n in s._asyncDataPromises&&(s._asyncDataPromises[n].cancelled=!0,s._asyncDataPromises[n]=void 0)}function U(s,n){const e={};for(const l of n)e[l]=s[l];return e}async function x(s){const{data:n,pending:e,error:l,refresh:a}=await $(()=>$fetch(s),"$nIfBrkE4uq");return n.value}const F={class:"default"},L={__name:"default",async setup(s){let n,e;const l=([n,e]=I(()=>x("/api/checkInstalled")),n=await n,e(),n),a=d(!l.data.isInstall),t=T();return a.value&&t.path!=="/install"&&q("install"),(f,_)=>(N(),z("div",F,[K(f.$slots,"default")]))}};export{L as default};
